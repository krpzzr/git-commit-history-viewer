## Какую структуру вы бы разработали для архитектуры интерфейса (дизайн компонентов, поток данных)?
- Перетащить логику из app/page.tsx в фичевые контейнеры, создать единый слой запросов и хуков (React Query), унести форматирование времени и парсинг заголовков в shared/lib, вынести базовые UI‑контролы в shared/ui, и оставить страницы как компоновщики без лишней логики фич.

## Как бы вы организовали кэширование, чтобы избежать ограничений по скорости и проблем с производительностью?
- Кэшировать ответы нашего API на короткий TTL, с ключами по параметрам (repo, page, per_page, query) через Vercel.
- Кэшировать нормализованные ответы GitHub (по ключу запроса).
- С помощью Webhooks GitHub (на push событие) вызывать `revalidateTag(repo)` и выполнять очистку ключей.

## Какая логика будет реализована на сервере, а какая на клиенте?
- Сервер:
  - Доступ к GitHub (секреты/токены), агрегация, нормализация, кэш.
  - Пагинация, поиск по коммитам (REST `/search/commits` + fallback).
  - Обработка вебхуков GitHub (push, rate‑limit события) → инвалидация/обновление кэша.
- Клиент:
  - Рендер UI, виртуализация, пагинация “Load more”.
  - Поиск — формирование запросов; состояние фильтров.
  - Никаких секретов; браузерный кэш по желанию (можно оставить по умолчанию и опираться на серверную инвалидацию).

## Как бы вы обеспечили масштабируемость и наблюдаемость системы (мониторинг, обработка ошибок, логирование)?
- Для масштабирования полагаться на горизонтальный скейлинг платформы (например, Vercel) плюс внешний кэш: CDN/Edge, Redis как слой данных, а корректность данных обеспечивать вебхуками и точечной инвалидацией. Реализиовать централизованные логи и метрики (например Grafana + Prometheus), со сквозным trace-id, чтобы видеть путь запроса от клиента до GitHub. Сделать предсказуемой обработку ошибок с понятными сообщениями пользователю, чтобы даже при глобальных сбоях интерфейс оставался работоспособным и диагностируемым.