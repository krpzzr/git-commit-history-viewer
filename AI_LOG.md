## Как я использовал ИИ
- Инструменты: ChatGPT (в роли pair‑programmer в Cursor).
- Задачи, где ИИ помог:
  - Быстрое проектирование структуры UI (Refresh, поиск, виртуализация списка, тема).
  - Настройка кеширования Next.js: `next: { revalidate, tags }`, `revalidateTag`, заголовки `Cache-Control`, `cache: 'no-store'`.
  - Миграция виртуализации: от самописного “оконного” рендера к react-virtuoso с `useWindowScroll` и ручной дозагрузкой.

## Стратегии/промпты
- Стартовал с краткой выжимки ТЗ в ChatGPT, чтобы быстрее декомпозировать задачу на подзадачи.
- Через Cursor попросил сгенерировать базовый скелет приложения (отображение коммитов), затем итеративно наращивал функционал.
- Маленькие итерации по файлам (чтобы не ломать рабочее состояние). Пример: “Сделай кнопку поиска с лоадером как RefreshButton”, “Сделай кеш с revalidateTag”
- Сначала объяснение, потом конкретная правка кода. Пример: "Не корреткно отображается время когда коммит был произведен. Обьясни из-за чего это могло случиться", "В существующей реализации в файле CommitItem перейди на committer.date + floor-округление"


## Где ИИ НЕ помог/что отбраковал
- Слепое “виртуализируй сам” сначала дало нестабильный скролл - отбраковал и перешёл на библиотеку (react‑virtuoso).
- Автолодер через IntersectionObserver с внутренним скроллом UX не понравился; заменено на один скролл окна + ручная кнопка.
- Много мелких правок после реализации решения от ИИ

## Влияние на процесс
- Ускорение первичной реализации (кеш, поиск, стили).
- Более быстрое локализованное исправление багов (тема/гидратация/кнопки).
- Риски: ИИ легко притаскивает лишнюю сложность (пример - самописная виртуализация). Сделал откат и установил библиотеку с минимально‑достаточным решением.

## Отдельные заметки
- Браузерный кэш - выключен; Data Cache - теги + инвалидация на Refresh. Это отвечает требованиям “избежать rate limits”, но оставляет контроль в наших руках.